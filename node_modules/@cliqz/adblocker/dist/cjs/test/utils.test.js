"use strict";
/*!
 * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
require("mocha");
const tokens_buffer_1 = require("../src/tokens-buffer");
const lists_1 = require("../src/lists");
const utils_1 = require("../src/utils");
const requests_1 = require("./data/requests");
const utils_2 = require("./utils");
const network_1 = require("../src/filters/network");
function t(tokens) {
    return new Uint32Array(tokens.map(utils_1.fastHash));
}
function checkCollisions(filters) {
    const hashes = new Map();
    for (const filter of filters) {
        const id = filter.getId();
        const found = hashes.get(id);
        const raw = (0, network_1.normalizeRawFilterOptions)(filter.toString());
        if (found !== undefined && raw !== found) {
            throw new Error(`expected ${raw} to not collide, found ${found}`);
        }
        hashes.set(id, raw);
    }
}
describe('utils.ts', () => {
    describe('#normalizeRawFilterOptions', () => {
        it('handles empty string', () => {
            (0, chai_1.expect)((0, network_1.normalizeRawFilterOptions)('')).to.equal('');
        });
        it('handle empty selector', () => {
            (0, chai_1.expect)((0, network_1.normalizeRawFilterOptions)('$css')).to.equal('$css');
            (0, chai_1.expect)((0, network_1.normalizeRawFilterOptions)('$stylesheet')).to.equal('$css');
        });
        it('does nothing on normalized', () => {
            for (const filter of ['/ads/', '/ads/$css', '/ads/$css,font']) {
                (0, chai_1.expect)((0, network_1.normalizeRawFilterOptions)(filter), filter).to.equal(filter);
            }
        });
        it('normalizes trailing wildcard', () => {
            (0, chai_1.expect)((0, network_1.normalizeRawFilterOptions)('*$css')).to.equal('$css');
        });
        it('ignores options from selector', () => {
            (0, chai_1.expect)((0, network_1.normalizeRawFilterOptions)('/ads/$first-party/still/selector$css')).to.equal('/ads/$first-party/still/selector$css');
        });
        it('returns lower-cased filter', () => {
            (0, chai_1.expect)((0, network_1.normalizeRawFilterOptions)('/Ads/')).to.equal('/ads/');
            (0, chai_1.expect)((0, network_1.normalizeRawFilterOptions)('/Ads/$CSS')).to.equal('/ads/$css');
        });
        it('removes $all option', () => {
            (0, chai_1.expect)((0, network_1.normalizeRawFilterOptions)('/ads/$all')).to.equal('/ads/');
        });
    });
    describe('#fastHash', () => {
        it('does not produce collision on network filters', () => {
            checkCollisions((0, lists_1.parseFilters)(utils_2.allLists, {
                loadCosmeticFilters: false,
                debug: true,
            }).networkFilters);
        });
        it('does not produce collision on cosmetic filters', () => {
            checkCollisions((0, lists_1.parseFilters)(utils_2.allLists, {
                loadNetworkFilters: false,
                debug: true,
            }).cosmeticFilters);
        });
        it('does not produce collision on requests dataset', () => {
            const networkFiltersFromRequests = [];
            for (const { filters } of requests_1.default) {
                for (const filter of filters) {
                    const parsed = network_1.default.parse(filter);
                    if (parsed === null) {
                        throw new Error(`Could not parse ${filter}`);
                    }
                    networkFiltersFromRequests.push(parsed);
                }
            }
            checkCollisions(networkFiltersFromRequests);
        });
        it('returns HASH_SEED for empty string and non-strings', () => {
            (0, chai_1.expect)((0, utils_1.fastHash)('')).to.equal(utils_1.HASH_SEED);
            (0, chai_1.expect)((0, utils_1.fastHashBetween)('', 0, 0)).to.equal(utils_1.HASH_SEED);
            // @ts-ignore
            (0, chai_1.expect)((0, utils_1.fastHash)([])).to.equal(utils_1.HASH_SEED);
        });
    });
    it('detects remaining space in buffer', () => {
        const buffer = new tokens_buffer_1.TokensBuffer(1);
        buffer.reset();
        (0, utils_1.tokenizeInPlace)('/foo/baz/baz', false, false, buffer);
        (0, chai_1.expect)(buffer.pos).to.equal(1);
        buffer.reset();
        (0, utils_1.tokenizeNoSkipInPlace)('/foo/baz/baz', buffer);
        (0, chai_1.expect)(buffer.pos).to.equal(1);
        buffer.reset();
        (0, utils_1.tokenizeWithWildcardsInPlace)('/foo/baz/baz', false, false, buffer);
        (0, chai_1.expect)(buffer.pos).to.equal(1);
    });
    it('#tokenizeWithWildcards', () => {
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('', false, false)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('', true, false)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('', false, true)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('', true, true)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo.barƬ*', false, false)).to.eql(t(['foo']));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo.barƬ*', false, true)).to.eql(t(['foo']));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo.barƬ*', true, false)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo.barƬ*', true, true)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('*foo.barƬ', false, false)).to.eql(t(['barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('*foo.barƬ*', false, false)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('*foo*barƬ*', false, false)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo*barƬ*', false, false)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo*barƬ', false, false)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo**barƬ', false, false)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo/bar baz', false, false)).to.eql(t(['foo', 'bar', 'baz']));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo/bar baz', true, false)).to.eql(t(['bar', 'baz']));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo/bar baz', true, true)).to.eql(t(['bar']));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo/bar baz', false, true)).to.eql(t(['foo', 'bar']));
        (0, chai_1.expect)((0, utils_1.tokenizeWithWildcards)('foo////bar  baz', false, true)).to.eql(t(['foo', 'bar']));
    });
    it('#tokenize', () => {
        (0, chai_1.expect)((0, utils_1.tokenize)('', false, false)).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenize)('foo', false, false)).to.eql(t(['foo']));
        (0, chai_1.expect)((0, utils_1.tokenize)('foo/bar', false, false)).to.eql(t(['foo', 'bar']));
        (0, chai_1.expect)((0, utils_1.tokenize)('foo-bar', false, false)).to.eql(t(['foo', 'bar']));
        (0, chai_1.expect)((0, utils_1.tokenize)('foo.bar', false, false)).to.eql(t(['foo', 'bar']));
        (0, chai_1.expect)((0, utils_1.tokenize)('foo.barƬ', false, false)).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenize)('*foo.barƬ', false, false)).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenize)('*foo*.barƬ', false, false)).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenize)('*foo*.barƬ', true, false)).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenize)('foo*.barƬ', false, false)).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenize)('foo.*barƬ', false, false)).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenize)('foo.barƬ*', false, false)).to.eql(t(['foo', 'barƬ']));
    });
    it('#tokenizeNoSkip', () => {
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('')).to.eql(t([]));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('foo')).to.eql(t(['foo']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('foo/bar')).to.eql(t(['foo', 'bar']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('foo-bar')).to.eql(t(['foo', 'bar']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('foo.bar')).to.eql(t(['foo', 'bar']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('foo.barƬ')).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('*foo.barƬ')).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('*foo*.barƬ')).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('*foo*.barƬ')).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('foo*.barƬ')).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('foo.*barƬ')).to.eql(t(['foo', 'barƬ']));
        (0, chai_1.expect)((0, utils_1.tokenizeNoSkip)('foo.barƬ*')).to.eql(t(['foo', 'barƬ']));
    });
    it('#hasUnicode', () => {
        for (let i = 0; i < 127; i += 1) {
            (0, chai_1.expect)((0, utils_1.hasUnicode)(`foo${String.fromCharCode(i)}`)).to.be.false;
        }
        (0, chai_1.expect)((0, utils_1.hasUnicode)('｡◕ ∀ ◕｡)')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)('｀ｨ(´∀｀∩')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)('__ﾛ(,_,*)')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)('・(￣∀￣)・:*:')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)('ﾟ･✿ヾ╲(｡◕‿◕｡)╱✿･ﾟ')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)(',。・:*:・゜’( ☻ ω ☻ )。・:*:・゜’')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)('(╯°□°）╯︵ ┻━┻)')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)('(ﾉಥ益ಥ）ﾉ ┻━┻')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)('┬─┬ノ( º _ ºノ)')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)('( ͡° ͜ʖ ͡°)')).to.be.true;
        (0, chai_1.expect)((0, utils_1.hasUnicode)('¯_(ツ)_/¯')).to.be.true;
    });
    it('#binLookup', () => {
        (0, chai_1.expect)((0, utils_1.binLookup)(new Uint32Array(0), 42)).to.be.false;
        (0, chai_1.expect)((0, utils_1.binLookup)(new Uint32Array([]), 42)).to.be.false;
        (0, chai_1.expect)((0, utils_1.binLookup)(new Uint32Array([42]), 42)).to.be.true;
        (0, chai_1.expect)((0, utils_1.binLookup)(new Uint32Array([1, 2, 3, 4, 42]), 42)).to.be.true;
        (0, chai_1.expect)((0, utils_1.binLookup)(new Uint32Array([1, 2, 3, 4, 42]), 1)).to.be.true;
        (0, chai_1.expect)((0, utils_1.binLookup)(new Uint32Array([1, 2, 3, 4, 42]), 3)).to.be.true;
        (0, chai_1.expect)((0, utils_1.binLookup)(new Uint32Array([1, 2, 3, 4, 42]), 43)).to.be.false;
        (0, chai_1.expect)((0, utils_1.binLookup)(new Uint32Array([1, 2, 3, 4, 42]), 0)).to.be.false;
        (0, chai_1.expect)((0, utils_1.binLookup)(new Uint32Array([1, 2, 3, 4, 42]), 5)).to.be.false;
    });
    describe('#binSearch', () => {
        it('returns -1 on empty array', () => {
            (0, chai_1.expect)((0, utils_1.binSearch)(new Uint32Array(0), 42)).to.equal(-1);
        });
        it('handles array of one element', () => {
            (0, chai_1.expect)((0, utils_1.binSearch)(new Uint32Array([1]), 42)).to.equal(-1);
            (0, chai_1.expect)((0, utils_1.binSearch)(new Uint32Array([42]), 42)).to.equal(0);
        });
        it('handles array of two elements', () => {
            (0, chai_1.expect)((0, utils_1.binSearch)(new Uint32Array([0, 1]), 42)).to.equal(-1);
            (0, chai_1.expect)((0, utils_1.binSearch)(new Uint32Array([1, 42]), 42)).to.equal(1);
            (0, chai_1.expect)((0, utils_1.binSearch)(new Uint32Array([42, 1]), 42)).to.equal(0);
            (0, chai_1.expect)((0, utils_1.binSearch)(new Uint32Array([42, 42]), 42)).not.to.equal(-1);
        });
        it('handles no match', () => {
            (0, chai_1.expect)((0, utils_1.binSearch)(new Uint32Array(10000), 42)).to.equal(-1);
        });
        it('handles match on first element', () => {
            const array = new Uint32Array(10000);
            for (let i = 1; i < array.length; i += 1) {
                array[i] = 1;
            }
            (0, chai_1.expect)((0, utils_1.binSearch)(array, 0)).to.equal(0);
        });
        it('handles match on last element', () => {
            const array = new Uint32Array(10000);
            array[array.length - 1] = 42;
            (0, chai_1.expect)((0, utils_1.binSearch)(array, 42)).to.equal(array.length - 1);
        });
    });
});
//# sourceMappingURL=utils.test.js.map