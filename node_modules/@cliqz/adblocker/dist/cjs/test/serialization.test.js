"use strict";
/*!
 * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
require("mocha");
const utils_1 = require("./utils");
const config_1 = require("../src/config");
const data_view_1 = require("../src/data-view");
const engine_1 = require("../src/engine/engine");
const cosmetic_1 = require("../src/filters/cosmetic");
const network_1 = require("../src/filters/network");
const lists_1 = require("../src/lists");
describe('Serialization', () => {
    const { cosmeticFilters, networkFilters } = (0, lists_1.parseFilters)(utils_1.allLists, new config_1.default({ debug: true }));
    describe('Config', () => {
        it('serializes with exact size', () => {
            const config = new config_1.default();
            const buffer = data_view_1.StaticDataView.allocate(config.getSerializedSize(), config);
            config.serialize(buffer);
            // Check size
            (0, chai_1.expect)(buffer.slice()).to.have.lengthOf(config.getSerializedSize());
            // Check deserialization
            buffer.seekZero();
            (0, chai_1.expect)(config_1.default.deserialize(buffer)).to.eql(config);
        });
    });
    describe('filters', () => {
        const buffer = data_view_1.StaticDataView.allocate(1000000, { enableCompression: false });
        const checkFilterSerialization = (Filter, filter) => {
            // Keep track of original ID to make sure it's preserved after lazy
            // attributes are set and filter is serialized/deserialized.
            const originalId = filter.getId();
            // Serialize filter
            buffer.seekZero();
            filter.serialize(buffer);
            // Reload filter
            buffer.seekZero();
            const deserialized = Filter.deserialize(buffer);
            // @ts-ignore
            (0, chai_1.expect)(deserialized.id).to.be.undefined;
            (0, chai_1.expect)(deserialized.getId()).to.equal(originalId);
            (0, chai_1.expect)(deserialized).to.eql(filter);
        };
        it('cosmetic', () => {
            for (let i = 0; i < cosmeticFilters.length; i += 1) {
                checkFilterSerialization(cosmetic_1.default, cosmeticFilters[i]);
            }
        });
        it('network', () => {
            for (let i = 0; i < networkFilters.length; i += 1) {
                checkFilterSerialization(network_1.default, networkFilters[i]);
            }
        });
    });
    describe('Engine', () => {
        it('fails with wrong version', () => {
            const engine = engine_1.default.parse('||domain');
            const serialized = engine.serialize();
            const version = serialized[0];
            serialized[0] = (serialized[0] + 1) % 256; // override version
            (0, chai_1.expect)(() => {
                engine_1.default.deserialize(serialized);
            }).to.throw();
            serialized[0] = version;
            (0, chai_1.expect)(engine_1.default.deserialize(serialized)).to.eql(engine);
        });
        it('check integrity', () => {
            const engine = engine_1.default.parse('||domain', { integrityCheck: true });
            const serialized = engine.serialize();
            for (let i = 0; i < serialized.length; i += 1) {
                const value = serialized[i];
                let randomValue = value;
                while (randomValue === value) {
                    randomValue = Math.floor(Math.random() * 255);
                }
                serialized[i] = randomValue;
                // Expect engine to throw
                (0, chai_1.expect)(() => {
                    engine_1.default.deserialize(serialized);
                }).to.throw();
                serialized[i] = value;
            }
            (0, chai_1.expect)(engine_1.default.deserialize(serialized)).to.eql(engine);
        });
        it('disable integrity check', () => {
            const engine = engine_1.default.parse('||domain', { integrityCheck: true });
            const serialized = engine.serialize();
            const end = serialized.length - 1;
            const value = serialized[end];
            serialized[end] += 1;
            (0, chai_1.expect)(() => {
                engine_1.default.deserialize(serialized);
            }).to.throw();
            serialized[end] = value;
            (0, chai_1.expect)(engine_1.default.deserialize(serialized)).to.eql(engine);
        });
        it('handles full engine', () => {
            const engine = new engine_1.default();
            engine.updateResources((0, utils_1.loadResources)(), 'resources1');
            engine.lists.set('list1', 'checksum');
            engine.update({
                newCosmeticFilters: cosmeticFilters,
                newNetworkFilters: networkFilters,
            });
            const baseSerialized = engine.serialize();
            let deserialized = engine_1.default.deserialize(baseSerialized);
            (0, chai_1.expect)(deserialized).to.eql(engine);
            let serialized = deserialized.serialize();
            (0, chai_1.expect)((0, utils_1.typedArrayEqual)(serialized, baseSerialized)).to.be.true;
            // Perform several deserializations in a row. Testing this is needed to
            // make sure the low-level typed array manipulation do not corrupt the
            // data.
            for (let i = 0; i < 3; i += 1) {
                deserialized = engine_1.default.deserialize(serialized);
                serialized = deserialized.serialize();
                (0, chai_1.expect)((0, utils_1.typedArrayEqual)(serialized, baseSerialized)).to.be.true;
            }
        });
    });
});
//# sourceMappingURL=serialization.test.js.map