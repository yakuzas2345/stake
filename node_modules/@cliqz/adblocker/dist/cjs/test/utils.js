"use strict";
/*!
 * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.typedArrayEqual = exports.typedArrayDiff = exports.getRawTrackerDB = exports.getNaughtyStrings = exports.loadResources = exports.allLists = exports.loadEasyListFilters = void 0;
const fs = require("fs");
const path = require("path");
const zlib = require("zlib");
const adblocker_1 = require("../adblocker");
function loadEasyListFilters() {
    return JSON.parse(fs.readFileSync(path.resolve(__dirname, 'data', 'easylist.json'), { encoding: 'utf-8' }));
}
exports.loadEasyListFilters = loadEasyListFilters;
function readAsset(filepath) {
    return fs.readFileSync(path.resolve(__dirname, '../', filepath), 'utf-8');
}
const PREFIX = 'https://raw.githubusercontent.com/cliqz-oss/adblocker/master/packages/adblocker/assets';
exports.allLists = (() => {
    return adblocker_1.fullLists
        .map((p) => path.join('assets', p.slice(PREFIX.length)))
        .map((p) => readAsset(p))
        .join('\n');
})();
function loadResources() {
    return readAsset('assets/ublock-origin/resources.txt');
}
exports.loadResources = loadResources;
function getNaughtyStrings() {
    return fs.readFileSync(path.resolve(__dirname, 'data', 'blns.txt'), 'utf-8').split('\n');
}
exports.getNaughtyStrings = getNaughtyStrings;
function getRawTrackerDB() {
    const trackerdb = JSON.parse(zlib.unzipSync(fs.readFileSync(path.resolve(__dirname, 'data', 'trackerdb_20221213.json.gz'))).toString('utf-8'));
    for (const [key, pattern] of Object.entries(trackerdb.patterns)) {
        if (pattern !== null && typeof pattern === 'object') {
            Object.assign(pattern, { key });
        }
    }
    for (const [key, category] of Object.entries(trackerdb.categories)) {
        if (category !== null && typeof category === 'object') {
            Object.assign(category, { key });
        }
    }
    for (const [key, organization] of Object.entries(trackerdb.organizations)) {
        if (organization !== null && typeof organization === 'object') {
            Object.assign(organization, { key });
        }
    }
    return trackerdb;
}
exports.getRawTrackerDB = getRawTrackerDB;
function typedArrayDiff(arr1, arr2) {
    const differences = [];
    if (arr1.byteLength !== arr2.byteLength) {
        differences.push(`Diff (length): ${JSON.stringify({
            arr1_length: arr1.byteLength,
            arr2_length: arr2.byteLength,
        })}`);
        return differences;
    }
    for (let i = 0; i < arr1.byteLength; i += 1) {
        if (arr1[i] !== arr2[i]) {
            differences.push(`Diff (values): ${JSON.stringify({
                arr1: arr1[i],
                arr2: arr2[i],
                i,
            })}`);
            break;
        }
    }
    return differences;
}
exports.typedArrayDiff = typedArrayDiff;
function typedArrayEqual(arr1, arr2) {
    return typedArrayDiff(arr1, arr2).length === 0;
}
exports.typedArrayEqual = typedArrayEqual;
//# sourceMappingURL=utils.js.map