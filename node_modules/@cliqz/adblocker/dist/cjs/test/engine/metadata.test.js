"use strict";
/*!
 * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
require("mocha");
const utils_1 = require("../utils");
const request_1 = require("../../src/request");
const engine_1 = require("../../src/engine/engine");
const utils_2 = require("../../src/utils");
const data_view_1 = require("../../src/data-view");
const metadata_1 = require("../../src/engine/metadata");
const patterns_1 = require("../../src/engine/metadata/patterns");
const categories_1 = require("../../src/engine/metadata/categories");
const organizations_1 = require("../../src/engine/metadata/organizations");
const map_1 = require("../../src/engine/map");
const network_1 = require("../../src/filters/network");
const ZYPMEDIA = {
    key: 'zypmedia',
    name: 'ZypMedia',
    category: 'advertising',
    organization: 'zypmedia',
    alias: null,
    website_url: 'http://www.zypmedia.com/',
    ghostery_id: '2742',
    domains: ['extend.tv'],
    filters: ['||sync.extend.tv^'],
};
const ZYPMEDIA_ORGANIZATION = {
    key: 'zypmedia',
    name: 'Zypmedia',
    description: 'ZypLink connects local media companies, advertising agencies and advertisers with the widest array of premium video and display impressions across desktop, mobile and connected TVs. ZypLink applies advanced geographic, demographic, contextual, behavioral and other targeting utilizing the best 3rd party data sources, proprietary 1st party data collected and segmented by ZypMedia, and 1st data supplied by advertisers (when available).',
    website_url: 'http://www.zypmedia.com/',
    country: null,
    privacy_policy_url: 'http://www.zypmedia.com/privacy-policy',
    privacy_contact: 'privacy@zypmedia.com',
    ghostery_id: '4668',
};
const ADVERTISING_CATEGORY = {
    key: 'advertising',
    name: 'Advertising',
    color: '#cb55cd',
    description: 'Includes advertising services such as data collection, behavioral analysis or retargeting.',
};
function sortPatterns(pattenrs) {
    return pattenrs.sort((pattern1, pattern2) => (0, utils_2.fastHash)(pattern1.name) - (0, utils_2.fastHash)(pattern2.name));
}
function sortCategories(categories) {
    return categories.sort((category1, category2) => (0, utils_2.fastHash)(category1.name) - (0, utils_2.fastHash)(category2.name));
}
function sortOrganizations(organizations) {
    return organizations.sort((organization1, organization2) => (0, utils_2.fastHash)(organization1.name) - (0, utils_2.fastHash)(organization2.name));
}
describe('#IPattern', () => {
    const view = data_view_1.StaticDataView.allocate(100000, { enableCompression: false });
    it('serialization', () => {
        for (const [name, pattern] of Object.entries((0, utils_1.getRawTrackerDB)().patterns)) {
            (0, chai_1.expect)((0, patterns_1.isValid)(pattern), name).to.be.true;
            if ((0, patterns_1.isValid)(pattern)) {
                view.setPos(0);
                (0, patterns_1.serialize)(pattern, view);
                (0, chai_1.expect)(view.getPos(), name).to.eql((0, patterns_1.getSerializedSize)(pattern));
                view.setPos(0);
                (0, chai_1.expect)((0, patterns_1.deserialize)(view), name).to.eql(pattern);
            }
        }
    });
    it('stored in CompactMap', () => {
        const inputPatterns = Object.values((0, utils_1.getRawTrackerDB)().patterns);
        const map = (0, patterns_1.createMap)(inputPatterns);
        // Make sure we can serialize and deserialize `map`
        const mapView = data_view_1.StaticDataView.allocate(1000000, { enableCompression: false });
        map.serialize(mapView);
        (0, chai_1.expect)(mapView.getPos()).to.eql(map.getSerializedSize());
        mapView.setPos(0);
        const deserializedMap = map_1.CompactMap.deserialize(mapView, patterns_1.deserialize);
        (0, chai_1.expect)(deserializedMap).to.eql(map);
        // Make sure we get the original values back
        const patterns = map.getValues();
        sortPatterns(inputPatterns);
        sortPatterns(patterns);
        (0, chai_1.expect)(patterns).to.eql(inputPatterns);
        for (const pattern of inputPatterns) {
            const keys = (0, patterns_1.getKeys)(pattern);
            for (const key of keys) {
                (0, chai_1.expect)(map.get(key)).to.deep.include(pattern);
            }
        }
    });
});
describe('#ICategory', () => {
    const view = data_view_1.StaticDataView.allocate(100000, { enableCompression: false });
    it('serialization', () => {
        for (const [name, category] of Object.entries((0, utils_1.getRawTrackerDB)().categories)) {
            (0, chai_1.expect)((0, categories_1.isValid)(category), name).to.be.true;
            if ((0, categories_1.isValid)(category)) {
                view.setPos(0);
                (0, categories_1.serialize)(category, view);
                (0, chai_1.expect)(view.getPos(), name).to.eql((0, categories_1.getSerializedSize)(category));
                view.setPos(0);
                (0, chai_1.expect)((0, categories_1.deserialize)(view), name).to.eql(category);
            }
        }
    });
    it('stored in CompactMap', () => {
        const inputCategories = Object.values((0, utils_1.getRawTrackerDB)().categories);
        const map = (0, categories_1.createMap)(inputCategories);
        // Make sure we can serialize and deserialize `map`
        const mapView = data_view_1.StaticDataView.allocate(1000000, { enableCompression: false });
        map.serialize(mapView);
        (0, chai_1.expect)(mapView.getPos()).to.eql(map.getSerializedSize());
        mapView.setPos(0);
        const deserializedMap = map_1.CompactMap.deserialize(mapView, categories_1.deserialize);
        (0, chai_1.expect)(deserializedMap).to.eql(map);
        // Make sure we get the original values back
        const categories = map.getValues();
        sortCategories(inputCategories);
        sortCategories(categories);
        (0, chai_1.expect)(categories).to.eql(inputCategories);
        for (const category of inputCategories) {
            (0, chai_1.expect)(map.get((0, categories_1.getKey)(category))).to.deep.include(category);
        }
    });
});
describe('#IOrganization', () => {
    const view = data_view_1.StaticDataView.allocate(100000, { enableCompression: false });
    it('serialization', () => {
        for (const [name, organization] of Object.entries((0, utils_1.getRawTrackerDB)().organizations)) {
            (0, chai_1.expect)((0, organizations_1.isValid)(organization), name).to.be.true;
            if ((0, organizations_1.isValid)(organization)) {
                view.setPos(0);
                (0, organizations_1.serialize)(organization, view);
                (0, chai_1.expect)(view.getPos(), name).to.eql((0, organizations_1.getSerializedSize)(organization));
                view.setPos(0);
                (0, chai_1.expect)((0, organizations_1.deserialize)(view), name).to.eql(organization);
            }
        }
    });
    it('stored in CompactMap', () => {
        const inputOrganization = Object.values((0, utils_1.getRawTrackerDB)().organizations);
        const map = (0, organizations_1.createMap)(inputOrganization);
        // Make sure we can serialize and deserialize `map`
        const mapView = data_view_1.StaticDataView.allocate(1000000, { enableCompression: false });
        map.serialize(mapView);
        (0, chai_1.expect)(mapView.getPos()).to.eql(map.getSerializedSize());
        mapView.setPos(0);
        const deserializedMap = map_1.CompactMap.deserialize(mapView, organizations_1.deserialize);
        (0, chai_1.expect)(deserializedMap).to.eql(map);
        // Make sure we get the original values back
        const organizations = map.getValues();
        sortOrganizations(inputOrganization);
        sortOrganizations(organizations);
        (0, chai_1.expect)(organizations).to.eql(inputOrganization);
        for (const organization of inputOrganization) {
            (0, chai_1.expect)(map.get((0, organizations_1.getKey)(organization))).to.deep.include(organization);
        }
    });
});
describe('#Metadata', () => {
    describe('#fromDomain', () => {
        const metadata = new metadata_1.Metadata({
            patterns: {
                zypmedia: ZYPMEDIA,
            },
            organizations: {
                zypmedia: ZYPMEDIA_ORGANIZATION,
            },
            categories: {
                advertising: ADVERTISING_CATEGORY,
            },
        });
        it('retrieves existing metadata', () => {
            (0, chai_1.expect)(metadata.fromDomain('test.sync.extend.tv')).to.eql([
                {
                    pattern: ZYPMEDIA,
                    organization: ZYPMEDIA_ORGANIZATION,
                    category: ADVERTISING_CATEGORY,
                },
            ]);
            (0, chai_1.expect)(metadata.fromDomain('extend.tv')).to.eql([
                {
                    pattern: ZYPMEDIA,
                    organization: ZYPMEDIA_ORGANIZATION,
                    category: ADVERTISING_CATEGORY,
                },
            ]);
        });
        it('returns undefined otherwise', () => {
            (0, chai_1.expect)(metadata.fromDomain('foo.com')).to.eql([]);
        });
        it('handles empty string', () => {
            (0, chai_1.expect)(metadata.fromDomain('')).to.eql([]);
        });
        it('handles invalid input', () => {
            (0, chai_1.expect)(metadata.fromDomain('$foo')).to.eql([]);
        });
    });
    describe('#fromFilter', () => {
        const metadata = new metadata_1.Metadata({
            patterns: {
                zypmedia: ZYPMEDIA,
            },
            organizations: {
                zypmedia: ZYPMEDIA_ORGANIZATION,
            },
            categories: {
                advertising: ADVERTISING_CATEGORY,
            },
        });
        it('retrieves existing metadata', () => {
            (0, chai_1.expect)(metadata.fromFilter(network_1.default.parse('||sync.extend.tv^'))).to.eql([
                {
                    pattern: ZYPMEDIA,
                    organization: ZYPMEDIA_ORGANIZATION,
                    category: ADVERTISING_CATEGORY,
                },
            ]);
        });
        it('returns undefined otherwise', () => {
            (0, chai_1.expect)(metadata.fromFilter(network_1.default.parse('||foo.com^'))).to.eql([]);
        });
    });
    describe('#fromId', () => {
        const metadata = new metadata_1.Metadata({
            patterns: {
                zypmedia: ZYPMEDIA,
            },
            organizations: {
                zypmedia: ZYPMEDIA_ORGANIZATION,
            },
            categories: {
                advertising: ADVERTISING_CATEGORY,
            },
        });
        it('retrieves existing metadata', () => {
            var _a;
            (0, chai_1.expect)(metadata.fromId(((_a = network_1.default.parse('||sync.extend.tv^')) === null || _a === void 0 ? void 0 : _a.getId()) || 0)).to.eql([
                {
                    pattern: ZYPMEDIA,
                    organization: ZYPMEDIA_ORGANIZATION,
                    category: ADVERTISING_CATEGORY,
                },
            ]);
        });
        it('returns undefined otherwise', () => {
            var _a;
            (0, chai_1.expect)(metadata.fromId(((_a = network_1.default.parse('||foo.com^')) === null || _a === void 0 ? void 0 : _a.getId()) || 0)).to.eql([]);
        });
    });
    describe('integration with FiltersEngine', () => {
        const rawTrackerDB = (0, utils_1.getRawTrackerDB)();
        let engine;
        beforeEach(() => {
            engine = engine_1.default.fromTrackerDB(rawTrackerDB);
        });
        it('loads trackerdb dump', () => {
            const patterns = Object.values(rawTrackerDB.patterns);
            const categories = Object.values(rawTrackerDB.categories);
            const organizations = Object.values(rawTrackerDB.organizations);
            // Make sure we can serialize and load the engine with metadata
            const serialized = engine.serialize();
            // expect(metadata.getSerializedSize()).to.eql(view.getPos());
            const deserialized = engine_1.default.deserialize(serialized);
            (0, chai_1.expect)(deserialized).to.eql(engine);
            // Make sure values stored can be retrieved
            (0, chai_1.expect)(deserialized.metadata).to.not.be.undefined;
            if (deserialized.metadata !== undefined) {
                (0, chai_1.expect)(sortPatterns(deserialized.metadata.getPatterns())).to.eql(sortPatterns(patterns));
                (0, chai_1.expect)(sortCategories(deserialized.metadata.getCategories())).to.eql(sortCategories(categories));
                (0, chai_1.expect)(sortOrganizations(deserialized.metadata.getOrganizations())).to.eql(sortOrganizations(organizations));
            }
        });
        describe('extends #match with metadata lookup', () => {
            // domains: ['extend.tv'],
            const filter = network_1.default.parse('||sync.extend.tv^');
            filter === null || filter === void 0 ? void 0 : filter.getId();
            it('returns metadata', () => {
                (0, chai_1.expect)(engine.match(request_1.default.fromRawDetails({ url: 'https://sync.extend.tv/' }), true /* withMetadata */)).to.eql({
                    exception: undefined,
                    filter,
                    match: true,
                    metadata: [
                        {
                            'category': ADVERTISING_CATEGORY,
                            'organization': ZYPMEDIA_ORGANIZATION,
                            'pattern': ZYPMEDIA,
                        },
                    ],
                    redirect: undefined,
                });
            });
            it('handles exceptions', () => {
                const exception = '@@||extend.tv';
                const exceptionFilter = network_1.default.parse(exception);
                exceptionFilter === null || exceptionFilter === void 0 ? void 0 : exceptionFilter.getId();
                engine.updateFromDiff({ added: [exception] });
                (0, chai_1.expect)(engine.match(request_1.default.fromRawDetails({ url: 'https://sync.extend.tv/' }), true /* withMetadata */)).to.eql({
                    exception: exceptionFilter,
                    filter,
                    match: false,
                    metadata: [
                        {
                            'category': ADVERTISING_CATEGORY,
                            'organization': ZYPMEDIA_ORGANIZATION,
                            'pattern': ZYPMEDIA,
                        },
                    ],
                    redirect: undefined,
                });
            });
        });
        describe('#getPatternMetadata', () => {
            it('matches agaist network filters', () => {
                (0, chai_1.expect)(engine.getPatternMetadata(request_1.default.fromRawDetails({ url: 'https://sync.extend.tv/' }))).to.eql([
                    {
                        'category': ADVERTISING_CATEGORY,
                        'organization': ZYPMEDIA_ORGANIZATION,
                        'pattern': ZYPMEDIA,
                    },
                ]);
            });
            it('by default does not match against domains', () => {
                (0, chai_1.expect)(engine.getPatternMetadata(request_1.default.fromRawDetails({ url: 'https://extend.tv/' }))).to.eql([]);
            });
            it('matches against domains with getDomainMetadata option', () => {
                (0, chai_1.expect)(engine.getPatternMetadata(request_1.default.fromRawDetails({ url: 'https://sync.extend.tv/' }), {
                    getDomainMetadata: true,
                })).to.eql([
                    {
                        'category': ADVERTISING_CATEGORY,
                        'organization': ZYPMEDIA_ORGANIZATION,
                        'pattern': ZYPMEDIA,
                    },
                ]);
            });
        });
    });
    describe('e2e', () => {
        it('loads trackerdb dump', () => {
            const rawTrackerDB = (0, utils_1.getRawTrackerDB)();
            const patterns = Object.values(rawTrackerDB.patterns);
            const categories = Object.values(rawTrackerDB.categories);
            const organizations = Object.values(rawTrackerDB.organizations);
            const metadata = new metadata_1.Metadata(rawTrackerDB);
            // Make sure we can serialize and load the metadata
            const view = data_view_1.StaticDataView.allocate(2000000, { enableCompression: false });
            metadata.serialize(view);
            // expect(metadata.getSerializedSize()).to.eql(view.getPos());
            view.setPos(0);
            const deserializedMetadata = metadata_1.Metadata.deserialize(view);
            (0, chai_1.expect)(deserializedMetadata).to.eql(metadata);
            // Make sure values stored can be retrieved
            (0, chai_1.expect)(sortPatterns(deserializedMetadata.getPatterns())).to.eql(sortPatterns(patterns));
            (0, chai_1.expect)(sortCategories(deserializedMetadata.getCategories())).to.eql(sortCategories(categories));
            (0, chai_1.expect)(sortOrganizations(deserializedMetadata.getOrganizations())).to.eql(sortOrganizations(organizations));
            for (const pattern of patterns) {
                const organization = pattern.organization
                    ? rawTrackerDB.organizations[pattern.organization]
                    : null;
                const category = rawTrackerDB.categories[pattern.category];
                for (const domain of pattern.domains) {
                    (0, chai_1.expect)(metadata.fromDomain(domain), domain).to.deep.include({
                        pattern,
                        organization,
                        category,
                    });
                }
                for (const filter of pattern.filters) {
                    const parsedFilter = network_1.default.parse(filter);
                    if (parsedFilter !== null) {
                        (0, chai_1.expect)(metadata.fromFilter(parsedFilter)).to.deep.include({
                            pattern,
                            organization,
                            category,
                        });
                    }
                }
            }
        });
    });
});
//# sourceMappingURL=metadata.test.js.map